---
layout: post
title: "Greedy Algorithm"
date: 2016-07-06 22:44:20 +0800
comments: true
categories: Algorithm
---
- list element with functor item
{:toc}

贪心算法在每一步都做出当时看起来最佳的选择。它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。

<!--more-->

## 1. 活动选择问题

目标是选出一个最大的相互兼容的活动集合。

### 动态规划
设 $s_{ij}$ 表示在活动 $a_i$ 结束之后开始，且在 $a_j$ 开始之前结束的那些活动的集合。如果 $c[i,j]$ 表示集合的最优解大小，则,

$$
c[i,j] =\left\{\begin{matrix}
0 & if(s_{ij}\neq \phi ) \\ 
\underset{a_k\in s_{ij}}{max} \{c[i,k] + c[k,j] + 1\} & if(s_{ij}= \phi )
\end{matrix}\right.
$$

因为面临这样的选择：$s_{ij}$ 中的最优解包含哪个活动 $a_k$。所以动态规划算法需要考查它所有的活动。

### 贪心选择
每次选择 $s$ 中最早结束的活动。

## 2. 算法实现

贪心算法通常都是自顶向下的设计：做出一个选择，然后求解剩下的那个子问题，而不是自底向上地求解出很多子问题，然后再做出选择。此外也可以很容易地将算法转换为迭代的形式。

## 3. 算法原理

贪心算法的两个关键要素：贪心选择性质和最优子结构

### 贪心选择性质
可以通过做出局部最优的选择来构造全局最优解。这也是贪心算法与动态规划的不同之处，在动态规划中每个步骤都有多种选择，选择通常依赖于子问题的解，例如：

$$
c[i,j]=\underset{i\leq k\leq j}{max}\{c[i,k]+c[k,j]+1\}
$$

当然，我们必须证明每个步骤做出贪心选择能生成全局最优解。首先考查某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似的最优解（子问题的最优解）。

### 最优子结构
如果一个问题的最优解包含了其他子问题的最优解，则称此问题具有最优子结构性质。

## 4. 贪心对动态规划

两种算法都利用了最优子结构性质，很相似。但是两者有细微差别。比如<code>0-1背包问题</code>和<code>分数背包问题</code>。<code>分数背包问题</code>可以用贪心算法，但是<code>0-1背包问题</code>不能用贪心算法。因为对<code>0-1背包问题</code>使用贪心算法时不能保证背包装满，而空闲的空间降低了单位重量的价值。