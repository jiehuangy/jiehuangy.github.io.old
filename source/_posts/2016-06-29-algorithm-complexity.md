---
layout: post
title: "算法复杂度分析"
date: 2016-06-29 23:47:10 +0800
comments: true
categories: 
---

**算法分析指的是分析算法的代码，估计出操作的数目，或称算法的“步数”。**
之所以分析算法步数，是因为：**1.** 步数确实能反映执行时间——步数越多执行时间就越长；**2.** 算法的步数不依赖于平台，更 容易分析和比较。

<!--more-->

算法通常都设计成能处理任意大小的输入数据，这就导致算法的步数并不是固定的，而 是随着问题规模的变化而变化，因此算法的步数可表示为问题规模的函数。**算法分析不仅要考虑算法步数与 n 的关系，更重要的是还要考虑“当 n 逐渐增大时” 算法复杂度会如何变化。**

因此说 A 算法比 B 算法好，并不是指对于特定的 n，A 比 B 节省 50%的时间，而是指随着 n 的不断增大，A 对 B 的优势会越来越大。

### 算法复杂度的大 O 表示法
“大 O 表示法”根据“步数” $f(n)$ 函数的增长率特性来刻画函数，可以用来描述算法的复杂度。

如果存在正常数 c，使得只要 n 足够大（例如超过某个 n0）， 函数 $f(n)$ 的值都不会超过 $c×g(n)$，即当 n > n0 时，
$$ f(n) <= c \times g(n) $$
则可记为
$$ f(n) = O(g(n)) $$
其中，n 对应于问题规模，$f(n)$ 是算法需执行的步数，$g(n)$ 是表示增长数 量级的某个函数。**说算法的复杂度为 $O(g(n))$，意思就是当 n 足够大时，该算法的执行步数（时间）永远不会超过  $c×g(n)$。**

**实际分析算法时**，为了使 $O(g(n))$ 中的 $g(n)$ 函数尽量简单，在得到算法的步数表达式 $f(n)$ 之后，可以利用两条规则来简化推导，直接得出 $f(n)$ 的大 O 表示。规则如下：
**（1）如果 $f(n)$ 是若干项之和，则只需保留最高次项，省略所有低次项；**
**（2）如果 $f(n)$ 是若干项之积，则可省略任何常数因子。**
以上两条规则告诉我们，在分析算法代码时可以忽略许多代码，而只关注那些嵌套层数最多、并且每一层循环的循环次数都与问题规模 n 有关的循环。

