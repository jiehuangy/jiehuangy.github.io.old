---
layout: post
title: "Sorting"
date: 2016-07-06 20:38:32 +0800
comments: true
categories: Algorithm
---
- list element with functor item
{:toc}

希尔排序相当于插入排序，同属于插入排序类；堆排序相当于选择排序的升级，同属于选择类排序；而快速排序是冒泡排序的升级，同属于交换排序类。

<!--more-->

### 排序的稳定性
假设 $k_i = k_j$，且在排序前 $i<j$。如果排序后仍然  $i<j$，则称所用排序算法是稳定的。否则排序算法不稳定。


----------


### 冒泡排序 (Bubble Sort)
思想：两两比较相邻记录的数值，如果反序则交换，直到没有反序的记录为止。

{% imgcap center {{ root_url }}/images/2016-07-06-sorting-bubble-sort.png 512 512 %}


复杂度：时间复杂度为 $O(n^2)$

----------

### 选择排序 (Selection Sort)
思想：在确定第 $i$ 个位置的数值时，从 $[i+1, n)$中选出数值最小的记录，并和第 $i$ 个记录交换。

复杂度：时间复杂度为 $O(n^2)$，尽管与冒泡排序相同，但是性能上优于冒泡排序。

----------

### 插入排序 (Insertion Sort)
思想：将一个记录插入到已经排好序的有序表中，从而得到新的、录数增加1的有序表。

{% imgcap center {{ root_url }}/images/2016-07-06-sorting-insertion-sort.png 512 256 %}

复杂度：时间复杂度为 $O(n^2)$，但是性能上优于冒泡排序和选择排序。

----------

### 希尔排序 (Shell Sort)
插入排序的效率在某些时候很高，比如，记录本身就是基本有序的。还有就是记录数比较少时，直接插入的优势比较明显。希尔排序是插入排序的改进。

思想：分割待排序的记录，减少待排序记录的个数。将相距某个“增量”的记录组成一个子序列（实现跳跃式移动），在子序列内分别进行插入排序，使得结果基本有序。最后对整个序列插入排序。

复杂度：时间复杂度为 $O(n^{3/2})$。

注：由于记录是跳跃式的移动，希尔排序不是稳定的排序算法。

----------

### 堆排序 (Heap Sort)
如果可以做到在每次选择到最小记录的同时，并根据比较结果对其记录做出相应的调整，那样排序的总体效率会很高。堆排序就是对选择排序的改进。

思想：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根结点。将它移走，然后将剩余 n-1 个记录重新构造成一个大顶堆，这样就能得到 n 个元素中次大的值。如此反复得到一个有序序列。

复杂度：堆初始化的时间复杂度是 $O(n)$，重建堆的时间复杂度为 $O(nlogn)$。堆排序堆原始序列的状态不敏感，所以它的最好，平均，最坏时间复杂度是 $O(nlogn)$。

注：由于记录的比较和交换是跳跃式进行的，堆排序不是稳定的排序算法。

----------

### 归并排序 (Merge Sort)
思想：将待排序序列看做是 n 个有序的子序列，每个子序列的长度为 1，然互两两归并得到 [n/2] 个长度为 2 或 1 的有序子序列，再两两归并。如此重复直到长度为 n 的有序序列为止。

{% imgcap center {{ root_url }}/images/2016-07-06-sorting-merge-sort.png 512 256 %}

复杂度：最好，平均，最坏时间复杂度都是 $O(nlogn)$。由于在 Merge 的过程中需要与记录序列同样数量的存储空间存放结果，所以空间复杂度是 $O(n)$。

注：归并排序需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。

----------

### 快速排序 (Quick Sort)
思想：通过一趟排序将记录分割成独立的两部分，其中一部分记录的数值比另一部分记录的数值小。然后分别对这两部分继续排序，以达到整个序列有序的目的。

{% imgcap center {{ root_url }}/images/2016-07-06-sorting-quick-sort.png 512 256 %}

复杂度：最有情况下，Partition 每次划分的很均匀，时间复杂度为 $O(nlogn)$。最坏情况下，待排序列为正序或者反序，时间复杂度为 $O(n^2)$。平均情况下，时间复杂度可证明为 $O(nlogn)$。

注：由于记录的比较和交换是跳跃式进行的，快速排序不是稳定的排序算法。

----------

### 桶排序 (Bucket Sort)
之前介绍的排序算法都是基于两个数值之间的比较来确定位置的先后关系。桶排序则不是，所以它比快排还快，能够在  $O(n)$ 的时间内完成。但是缺点是非常耗费空间，如果序列中最大数为 m，那么需要 m 个桶。

思想：把记录 a[i] 放入第 a[i] 个桶中。

[6 2 4 1 5 9]           待排数组

[0 1 2 0 4 5 6 0 0 9]   空桶

[0 1 2 3 4 5 6 7 8 9]   桶编号(实际不存在)

{% imgcap center {{ root_url }}/images/2016-07-06-sorting-bucket-sort.png 512 256 %}

复杂度：时间复杂度$O(n)$

注：桶排序是稳定的

```cpp
int[] bucket_sort(int[] unsorted, int maxNumber = 99)
{
   int[] sorted = new int[maxNumber + 1];
   for (int i = 0; i < unsorted.Length; i++)
	   sorted[unsorted[i]] = unsorted[i];
   return sorted;
```


----------

### 计数排序 (Counting Sort)
思想：计数排序假设 n 个输入元素中的每一个都是介于 [0, k] 的整数，此处k为某个整数。计数排序顾名思义离不开计数，我们要计的是输入元素中相同元素出现的次数。对每一个输入元素x，确定小于x的元素的个数，那样排序之后，x在最终输出数组中的位置就可以确定了。

假定输入数组为 A[1..n]，他们的值均位于 0~k 之间，输出排序之后的数组为 B[1..n]，以及临时存储数组 C[0..k]。计数排序的伪代码如下：

```cpp
memset(C,sizeof(C),0);  //C数组置零  
for i=1 to n do  
    C[A[i]]++;          //统计输入数组中相同元素的个数  
for i=2 to k do  
    C[i] = C[i]+C[i-1]; //C[i]表示输入数组中小于或者等于i的元素个数  
for i=n downto 1 do  
    B[C[A[i]]] = A[i];  //把每一个A[i]放到输出数组中相应位置上  
    C[A[i]]--;          //如果有几个相同元素时,当然不能放在同一个位置了。
```

计数排序特点：
1.  提前必须是已知待排序的关键字为整型且范围已知。
2.  时间复杂度为O(n+k)，不是基于比较的排序算法，因此效率非常之高。
3.  稳定性好，这个是计数排序非常重要的特性，可以用在后面介绍的基数排序中。
4.  但需要一些辅助数组，如C[0..k]，因此待排序的关键字范围0~k不宜过大。
