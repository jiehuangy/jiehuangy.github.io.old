---
layout: post
title: "Back Tracking"
date: 2016-07-06 20:34:10 +0800
comments: true
categories: Algorithm
---

#### 1. 概念
　　回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
　　许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

<!--more-->

#### 2.基本思想
　　在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯（其实回溯法就是对隐式的深度优先搜索算法）。

#### 3. 解题步骤
1. 针对所给问题，确定问题的解空间，问题的解空间应至少包含问题的一个（最优）解。
2. 确定结点的扩展搜索规则
3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

#### 4. 算法框架
1. 问题框架：
设问题的解是一个 n 维向量 (a1,a2,………,an)，约束条件是 ai(i=1,2,3,…..,n) 之间满足某种条件，记为 f(ai)。


2. 递归的算法框架：
回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：

```cpp
int a[n];
try(int i)
{
  if(i>n)
    输出结果; 
  else
  {
    for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
    {
      if(fun(j))     // 满足限界函数和约束条件
      {
        a[i] = j;
        ...          // 其他操作
        try(i+1);
        回溯前的清理工作（如a[i]置空值等）;
      }
    }
  }
} 
```
