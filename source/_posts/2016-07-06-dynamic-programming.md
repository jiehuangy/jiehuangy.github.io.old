---
layout: post
title: "Dynamic Programming"
date: 2016-07-06 21:02:53 +0800
comments: true
categories: Algorithm
---
- list element with functor item
{:toc}

动态规划应用于子问题重叠问题，分治算法会反复求解那些公共子问题，而动态规划算法会对子问题只求解一次，将其解保存在一个表格中，避免不必要的计算。


<!--more-->

## 动态规划算法四步骤：
1. 刻画一个最优解的结构特征 (最优子结构)
2. 递归地定义最优解的值
3. 计算最优解的值，通常采用自底向上的方法
4. 利用计算出的信息构造一个最优解

## 动态规划原理
适用动态规划方法求解的最优问题应该具备两个要素：**最优子结构**和**子问题重叠**

### 最优子结构
如果原问题的最优解包含其子问题的最优解，就称此问题具有最优子结构。

发掘最优子结构性质的过程中，遵循如下模式：
1. 证明问题最优解的第一个组成部分是做出一个选择，做出这次选择会产生一个或多个待解决的子问题。
2. 在第一步选择中，假定已经知道哪种选择会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道这种选择。
3. 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。
4. 利用“剪切-粘贴” (cut-paste) 技术证明：作为构成原问题最优解的组成部分，每一个子问题的最优解就是它本身的最优解。

我们可以用子问题的个数和每个子问题需要考察多少种选择这两个因素的乘积来粗略分析动态规划算法的运行时间。

在动态规划方法中，通常自底向上地使用最优子结构，也就是说，首先求得子问题的最优解，然后在其中进行选择来求原问题的最优解。

注：动态规划子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。放过来说，就是要避免求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用。

### 重叠子问题
如果递归算法反复求解相同的子问题，称最优化问题具有重叠子问题 (overlapping subproblems) 性质。

## 动态规划两种等价的实现方法

### 带备忘的自顶向下 (top-down with memoization)
仍按自然递归形式编写过程，但过程中会保存每个子问题的解。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是则直接返回保存的结果；否则按通常方式计算这个子问题，并保存结果。

### 自底向上 (bottom-up method)
将子问题按规模排序，按由小自大顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。

两种算法具有相同的渐进运行时间，但自底向上算法会比自顶向下备忘算法快(相差一个常量系数)，因为自底向上算法没有递归调用的开销。

## 应用
### 1. 石子合并问题
（1）有N堆石子，现要将石子有序的合并成一堆，规定如下：每次只能移动**任意**的2堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费最小（或最大）。

分析：当然这种情况是最简单的情况，合并的是任意两堆，直接贪心即可，每次选择最小的两堆合并。本问题实际上就是哈夫曼的变形。

（2） 有N堆石子，现要将石子有序的合并成一堆，规定如下：每次只能移动**相邻**的2堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费最小（或最大）。

分析：我们熟悉矩阵连乘，知道矩阵连乘也是每次合并相邻的两个矩阵，那么石子合并可以用矩阵连乘的方式来解决。

设dp[i][j]表示第i到第j堆石子合并的最优值，sum[i][j]表示第i到第j堆石子的总数量。那么就有状态转移公式：

$$dp[i][j]=\left\{\begin{matrix}
0, if(i =j) \\ 
min(dp[i][k]+dp[i][k+1]+sum[i][j]), other
\end{matrix}\right.$$

（3） 问题(2)的是在石子排列是直线情况下的解法，现在考虑把石子改为环形排列。因为石子绕成一个环，不是一条直线，所以 dp[i][j] 的含义应为从第 i 堆开始，合并 j 堆石子能得到的最优值。则易得状态转移方程为:

$$dp[i][j] = min(dp[i][k]+dp[(i+k)\%n][j-k]+sum[i][j])$$

